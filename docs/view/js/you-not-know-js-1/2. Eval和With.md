---
title: Eval和With
author: kebobo
date: '2023-10-09'
---

## Eval 和 With 功能介绍

Eval: 可以对一段包含一个或多个声明的“代码”字符串进行演算，并借此来修改已经存在的词法作用域（在运行时）
With：通过将一个对象的引用当作作用域来处理，将对象的属性当作作用域中的标识符来处理，从而创建了一个新的词法作用域（同样是在运行时）。

## Eval 和 With 的作用域

非严格模式下运行 eval()会修改当前的词法作用域。eval 里面的代码会被当作本来就在那里一样处理（词法分析阶段，欺骗解析器代码本来就在那里）。

```javascript
function foo(str, a) {
  eval(str); // 欺骗！
  console.log(a, b);
}
var b = 2;
foo('var b = 3; ', 1); // 1, 3
```

正如上面例子，eval 中的 `var b = 3;` 被当作本来就在那里。最后修改了 foo 函数的词法作用域。

With 的用法也很好理解

```javascript
var obj = {
  a: 1,
  b: 2,
  c: 3,
};
// 单调乏味的重复"obj"
obj.a = 2;
obj.b = 3;
obj.c = 4;
// 简单的快捷方式
with (obj) {
  a = 3;
  b = 4;
  c = 5;
}
```

with 里面的作用域直接就是传入的对象了，直接访问对象的属性即可，不过值得注意的是，如果 with 里面存在不属于对象的变量赋值时，会直接把值赋值到全局作用域上。

```javascript
function foo(obj) {
  with (obj) {
    a = 2;
  }
}
var o1 = {
  a: 3,
};
var o2 = {
  b: 3,
};
foo(o1);
console.log(o1.a); // 2
foo(o2);
console.log(o2.a); // undefined
console.log(a); // 2 —— a被泄漏到全局作用域上了！
```

## Eval 和 With 的性能问题

对于这两个功能，我们是不建议使用的，因为在严格模式下，他们都表现出与非严格模式下不一样的行为。

严格模式下：

- Eval 会产生自己的作用域。如果字符串代码中有声明变量或者函数，是无法被外部调用的。
- With 被完全禁止使用

另外一个不推荐使用的理由是：在编译阶段，这两个特性不会进行性能优化，导致运行变慢。

原因是词法分析阶段无法明确知道 eval(..)会接收到什么代码，这些代码会如何对作用域进行修改（非严格模式下），也无法知道传递给 with 用来创建新词法作用域的对象的内容是什么。当引擎在代码中发现了 eval(..)或 with，它只能简单地假设关于标识符（变量、函数）位置的判断都是无效的（我的理解：当前作用域里面的变量、函数都 **不会进行查找优化** ）。

正是因为这样，出现了 eval(..)或者 with 的地方，所有优化都是没有意义的，因此引擎不会做任何优化。
